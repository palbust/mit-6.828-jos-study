#### 2. lab2

###### 2.1 Physical Page Management

这部分完成的是物理页初始化及其管理的相关函数。

- static void * boot_alloc()

  这是在物理页管理数组初始化前用于物理内存分配的函数。实现方式也很朴素，获取装载到内存中的内核最高的未使用的虚拟地址，将其按页对齐后得到起始地址，从这个地址往后以页为单位进行内存分配。

- void page_init()

  这个函数会初始化boot_alloc分配得到的物理页管理数组。大多数的物理页都应该被描述成空闲状态并且被插入到空闲链表中。一些需要保留的物理页如下所述：

  - 第一个物理页，这是为了保护BIOS和实模式下的IDT等相关数据。
  - 从0x0A0000开始到0x100000的物理页，这片384KB大小的空间留给操作系统I/O使用。
  - 加载内核的物理页。
  - 内核之后的由boot_alloc分配给页表目录和物理页管理数组的物理页。

- struct PageInfo * page_alloc(int alloc_flags)

  这个函数是在物理页管理数组初始化完成后真正用来分配物理内存的函数，此时不应再使用boot_alloc()。它会从非空的空闲链表中取下一个物理页分配出去，并根据alloc_flags中alloc_zero的设置与否来决定是否清空该物理页的数据。

- void page_free(struct PageInfo *pp)

  这个函数先检查被释放的物理页是否引用计数已经为0，若不为0说明还在使用中不能被释放；还需判断link域是否为0，若不为0则说明已经在空闲链表中，其出现double free现象应当报错。通过检测的物理页就被插入到空闲链表中。

###### 2.2 Virtual Memory

这部分实现的是对二级页表进行操作的函数。

- pte_t * pgdir_walk(pde_t *pgdir, const void *va, int create)

  pgdir是页表目录，va是待查找的虚拟地址，create决定当va所在页表未分配时是否分配。该函数就是根据va的高10位找到它所在页表的索引，然后从页表目录中取出来，若不存在且create为真就调用page_alloc将该页表映射到一个物理页。拿到页表后再根据va的中间10位得到其在页表内部的索引，由索引及页表得到指向va映射物理页的指针。

  在本函数中若是分配了新的页表，将其对应的物理地址存到页表目录中，并且需要设置可访问、可写、用户可用的权限标志。

- struct PageInfo * page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)

  该函数用于寻找va映射的物理页，并将其所在页表中的对应指针存储到pte_store中。后一个操作是为了方便page_remove移除page之后置空，因此其他调用page_lookup的函数不应传递pte_store。

- void page_remove(pde_t *pgdir, void *va)

  该函数利用page_lookup找到va映射的物理页，将其引用计数减一，当引用计数为0时就使用page_free释放该物理页。随后利用pte_store指针将va对应页表的相应索引处置空。最后需要注意的是每次成功移除一个物理页都要刷新TLB，TLB是一个高速缓存，用于加快内存转换的速度，刷新是为了清除TLB中被remove的物理页对应表项。

- int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)

  该函数要将va映射的物理页改为pp，因此先page_remove掉原先的物理页。注意当原先物理页与pp相同时，这样的操作可能会导致映射的物理页也存在于空闲链表上，因此要在page_remove前就增加pp的引用计数。然后将pgdir_walk找到的指向va映射物理页的指针改为指向pp对应物理地址，同时权限在perm的基础上还要增加可访问的权限。

- static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)

  该函数的作用是将[va,va+size)映射到[pa,pa+size)，其中va，pa，size都为物理页大小的整数倍。实现方式就是不断地调用pgdir_walk获取指向va映射物理页的指针，将其指向改为pa即可，同时注意权限在perm的基础上还要增加可访问的权限。这个函数主要是为了方便下一部分中内核相关内存区域的映射。

###### 2.3 Kernel Address Space

这部分完成的是内核相关的一些内存区域的映射。

- 物理页管理相关数据结构的映射

  我们在第一部分中建立的物理页管理数组pages是负责描述各物理页状态的数据结构，既然它也是内存中的数据那么也需要映射到物理地址。由于内核虚拟地址与物理地址的转换就是加减内核基址，我们可以直接用boot_map_region建立这样的映射，通过这个虚拟地址访问的权限设置成仅内核可读可写。为了使用户也能够获取pages中的数据，我们还要将pages拷贝的虚拟地址也映射到内核中这块物理地址上，只是通过拷贝的虚拟地址访问时只能够读取，无法写入。通过逻辑上使用2块内存空间可以有效地区分内核与用户的权限，但实际上使用的是同一块物理内存，因此也没有浪费内存空间。

- 内核栈的映射

  内核栈的虚拟地址空间有1024个页大小，但实际上只有最高的8个页被映射到了物理页，低的那些作为屏障将内核栈与其他内存空间隔离开，避免栈在降低时写坏了其他内存中有用的数据。

- 内核本身的映射

  将内核加载基址之后的所有虚拟内存都映射到从0开始的物理地址。这是我们所有操作的大前提：内核虚拟地址与其映射的物理地址转换是通过加减内核加载基址实现的。

###### 2.4 总体流程

内核通过mem_init函数将以上3部分的初始化及检查串联起来。下面是mem_init的大致流程。

![mem_init](https://i.loli.net/2021/07/22/FYEqg1Vkm5ONAW3.png)

其中装载页表目录是通过设置cr3寄存器实现的，启用分页功能则是设置cr0寄存器中对应标志位。
