#### 5.lab5

###### 5.1 文件系统基本结构

- 扇区与块

  硬盘的存储以扇区为单位，在JOS中一个扇区大小是512字节，这个数字比较小，而磁盘又是低速设备，如果每次操作系统就读一个扇区的数据效率未免太低，因此在实现硬盘读写时操作系统是按若干个扇区进行一次操作的，这种单位被称为块，不难看出块大小一定是扇区大小的整数倍。在JOS中，块大小与页大小相同，都为4KB。

- 超级块

  这是用来存储写死了的基本参数的地方，例如块大小，磁盘大小，或是描述根目录的数据，与项目中的配置文件功能类似。随文件系统的复杂程度超级块的数目也会不同，在JOS中我们只需要一块就能够记录完这些必要的数据，因此我们的第1个块就是超级块(第0块用于存储更基本的数据，如bootloader，页表等)。

- 文件元数据

  所谓元数据就是描述数据的数据，与之前的许多lab相同，我们使用结构体来描述一个东西。File结构体的结构如下图所示

  ![](https://i.loli.net/2021/08/05/uHJZ78OfL5s9MD3.png)

  可以看出用于描述文件的属性有名字，大小，以及存储文件数据的块序号。不难看出文件数据的存储不是连续的，只是块内的数据连续，总体上是以块为单位散乱分布的，这种设计能够有效提供空间利用率。对于小文件，我们可以直接使用10个块序号来获取数据；而大文件也可以使用间接块指针获取一个存储了块序号的索引表来获取数据。在JOS中支持的最大文件大小为1034个块，约4.04MB。在现代操作系统中会使用更多级的索引来支持更大的文件。

  此外，File结构体还可以用来描述文件夹，只是原本存储文件数据的块中变为存储代表文件的File结构体数组。二者通过File结构体中的f_type属性来区分。

###### 5.2 文件系统

- I/O权限控制

  JOS实现用户读写磁盘的方法是启动一个特殊的用户进程，称为文件系统进程，专门赋予其IOPL权限，因此它能够执行in和out指令，而其他的用户进程都是无权进行磁盘I/O的，因此要进行磁盘读写只能通过IPC与文件系统进程通信来完成；在现代操作系统中实现磁盘I/O的部分则是在内核中的，通过驱动实现，为用户提供服务的接口就是系统调用。

- 块缓存

  磁盘是低速设备，如果每次读写磁盘数据都要访问磁盘，即使按块访问效率也太低。因此文件系统进程将用到的磁盘数据写入到内存中以供其他进程访问，在内存中进行多次修改的开销将会远小于磁盘，直到执行刷新操作才将更改后的数据写回磁盘。在文件系统进程中，从0x10000000开始到0xD0000000总计3GB的虚拟内存空间都用于磁盘I/O，该进程的缺页处理函数会将读入了磁盘数据的物理页与这部分空间中的虚拟内存建立映射。因此JOS能支持的缓存大小为3GB。

  要将磁盘中的3GB数据一次性读入内存是非常耗时的事情，因此JOS注册了一个缺页处理函数，只有当某个地址被访问到了，再从磁盘读入内存，这与高速缓存的实现思路相同，不同的地方是块缓存不会出现冲突而被换出的情况。

- bitmap

  这个数据结构用于记录每个块的空闲状态，每个块用1bit来表示，1为空闲，0为在使用，因此bitmap中每个元素可以存储32个块的状态。

- 文件操作

  基本函数调用顺序：walk_path->dir_lookup->file_get_block->file_block_walk

  - file_block_walk

    获取指向某个文件中第n块的块序号指针。若n超过10，则需要到f_indirect中找，f_indirect为空的话则根据alloc设置与否决定是否分配块给f_indirect。

  - file_get_block

    调用file_block_walk获取指向文件块序号的指针，如果指针指向一个空值，则为它分配一个块。

  - dir_lookup

    遍历dir文件夹所有块中的File结构体，比较其name属性是否与要找的文件或文件夹相同。

  - walk_path

    将path按'/'分割得到一系列文件夹以及最终要找的文件，从超级块获得的根目录开始用dir_lookup寻找，每次找到了则下一回从新找到的目录继续找新的文件夹，直到最终找到文件。

  基本操作可分为文件开启创建操作，文件读写操作和针对块的操作，第一种调用walk_path寻找目标文件，第二种根据传入的File结构体按块操作即可，第三种调用file_block_walk找到目标块进行操作。

- 文件系统接口

  在I/O权限控制中我们提到，JOS中只有文件系统进程拥有磁盘I/O操作权限，其他进程想要读写磁盘数据必须通过IPC与文件系统进程通信才行。

  因此文件系统进程在初始化文件系统之后就会进入死循环，为发出请求的进程提供服务，发出请求的进程通过设置传递的值来选择要执行的文件操作，通过映射物理页来传递参数——服务器使用0x0ffff000映射到传递的参数。除了open操作需要映射客户端虚拟地址到物理页以外，其余操作都不需要，实际上open操作是共享了一个fd结构体，其结构如下图所示

  ![image-20210805221639617](https://i.loli.net/2021/08/05/beiUOy5mjuknQNJ.png)

在共享了这个fd结构体之后，通信双方就能共享文件偏移，并且客户端能够通过文件id来指定要操作的文件。服务端使用一个OpenFile结构体数组来管理所有打开的文件，它是连接文件描述符fd与文件本身的桥梁。

![image-20210805222631875](https://i.loli.net/2021/08/05/3BTSaLkHJfvlIAt.png)

当接收到客户端传来的文件id时以其为索引到OpenFile结构体数组中找出对应文件的File结构体，配合上一部分中实现的文件操作函数完成读写等操作。最后操作的返回值通过ipc_send返回给客户端。

###### 5.3 spawn启动子进程

spawn与fork很类似，区别在于fork创建的子进程与父进程执行的是同一个程序，spawn会加载其他程序然后在新建的子进程环境中运行。因此，fork需要拷贝(Copy-on-Write)父进程的内存，而spawn不需要。但有一些东西不论fork还是spawn创建的子进程都需要与父进程共享，例如文件描述符，如果不共享那么进程间将无法通过管道通信；还有各种共享库等等。这些需要共享的内存在映射时被设置的权限多加上一个PTE_SHARE，这意味着新建子进程的这部分虚拟内存只需要映射到父进程中对应虚拟内存已经映射的物理页即可。

###### 5.4 question

- Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?

  不需要，因为标识I/O权限的标志位在eflags寄存器中，在切换进程环境时这个寄存器的值是存储在trapframe中的，不用担心会被切换后的进程破坏，切换回来时自然也可以正常从trapframe中恢复。